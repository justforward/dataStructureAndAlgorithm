package leetcode.weekend;

/*
    1）思路 根据位远算 aabb
        每次加入的时候进行判断这个数 是个奇数个还是在当前的偶数个

用 10位长度表示 'a'、'b'……，'j'的出现次数，
    1表示出现次数为奇数，每增加一个字符，就对指定位置进行异或计算，
    如："aba"，遍历字符串，前缀和的变化为 "" -> "a" -> "ab" -> "aba"，
    对应的二进制表示为 0（0000000000） ->
    1（0000000001）->
    3（0000000011）->
    2（0000000010）。
    用一个整数 state 记录从0开始到当前位置的前缀和， 得到当前位置的前缀和
    用一个数组 sum 存储前缀和状态出现的次数，
    遍历字符串，当出现以下两种情况是，更新最美字符串个数：

    1）子字符串的各个字符出现次数均为偶数次。对于前缀和来说，
    假如 长度为 a 子字符串的前缀和为 k，
        长度为 （a + b) 的子字符串的前缀和也为 k，
        则中间长度区间为 b 的子字符串的异或和为 0，
        即该子字符串的字母出现次数均为偶数，最美子字符串的增加个位为前缀和为 k 的状态的出现次数，即 ans += sum[k]
    2）子字符串的各个字符出现次数只有一个字符出现次数为奇数，
        即该子字符串的异或和只有一个位为 1。
        对于当前状态 state，
        存在前缀和 k 使得 state ^ k == (1 << i), (0 <= i < 10)，
        则前缀和 k 出现的次数为子字符串（满足只有一个字符出现次数为奇数）的增加个数，
        即在区间 [0,10) 遍历 i，计算所有 k （k = state ^ (1 << i)）的出现个数 count，ans += count

 */
public class leetcode_1915 {

    public static void main(String[] args) {
        // byte转换
    }

    public long wonderfulSubstrings1(String word) {
        int[] cnt = new int[1024];
        return 0L;

    }

    public long wonderfulSubstrings(String word) {
        //所有字符串的奇偶性
        int[] cnt = new int[1024];
        cnt[0] = 1;
        //前缀和
        int pre = 0;
        //结果
        long res = 0;
        //遍历所有的字符
        for (char c : word.toCharArray()) {
            //当前字符 c-'a' 为对应的 0-9 的映射, 移动到对应的位置上
            // [9,8,7,6,5,4,3,2,1,0]
            // [j i h g f e d c b a] a-j 映射到 0-9
            // [0 0 0 0 0 0 0 0 0 0] 对应位置上为1的时候, 说明这个字符出现了奇数次
            pre ^= (1 << (c - 'a'));
            //如果这个pre前缀和出现过, 说明当前和上一次出现这个pre之间的所有字符出现了 偶数次
            // 例如abb 第一次出现a pre = 0 ^ 1<<('a'-'a') = 1 这一轮解释前 cnt[pre] = 1
            // 到第二次出现b的时候, a对应的位置还是1因为后来没出现过a
            //                     bb 抵消了因为出现了偶数次
            // 所以当前的pre = 1, 这个是第二次出现pre = 1 所以 res += cnt[pre] 加的其实是 bb这个字符串对应出现的次数
            res += cnt[pre];
            //寻找两个前缀和，其异或结果的二进制数中恰好有一个 1 对应子串的各个字母的个数仅有一个为奇数
            //枚举当前前缀和的每个比特 即 1<<i (i 属于 [0:9])

            // 得到其中一位
            for (int i = 0; i < 10; i++) {
                //我们要寻找的是 0-9只有一个位置上有1的数 即 1<<i (i 属于 [0:9])
                //我们希望的是 找到两个前缀和 pre 和 之前出现的一个前缀和(暂时用 x 代替),
                // 这两个前缀和异或的结果如果为 1<<i 那么 从x对应的前缀和到当前位置中间的字符串一定有且仅有一个位置是1 其他位置都是0
                // 因为 pre ^ x = 1<<i  而 我们现在知道 pre 和 1<<i 那么 x = (x^pre)^pre 两个pre 亦或抵消了
                //                                                括号里是 1<<i ^ pre
                res += cnt[pre ^ (1 << i)];//如果这个前缀和存在, 那么从那个前缀和到现在中间出现的子串就是我们希望找的只有一个字符出现了奇数次, 其他都是偶数次
            }
            //当前这个前缀和出现的次数+1, 下次再出现这个前缀和的时候, 获取对应的结果
            cnt[pre]++;
        }
        return res;
    }
}

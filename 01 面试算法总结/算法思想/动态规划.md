
递归和动态规划都是将原问题拆成多个子问题然后求解，他们之间最本质的区别是，动态规划保存了子问题的解，避免重复计算。


```
# 1、基础题型

## 1.1 爬楼梯

1）dp(n) 爬第n个台阶有f(n)种方法。

2）dp(n-1) 再上一个台阶就是f(n) 了 ，dp(n-2) 再上两个台阶就是f(n) 了

3） 初始化，dp(1)=1 走上第一个台阶只需要一步 即只有一个方法，dp(2)=2 走到第二个台阶有两种方法

不考虑dp[0]如果初始化，只初始化dp[1] = 1，dp[2] = 2，然后从i = 3开始 递推，这样才符合dp[i]的定义

## 1.2 使用最小花费爬楼梯



## 1.3 不同路径

https://leetcode-cn.com/problems/unique-paths/

1）确定dp数组以及下标的含义
```
dp[i][j] 表示从0,0下标出发，到坐标为i，j 的有dp[i][j]条不同的路径
```

2）递推公式
```
dp[i][j]=dp[i-1][j]+dp[i][j-1] // 从这两个方向推导出来
```

3） 初始化
```
dp[i][0] 一定都是1 因为从坐标0,0 出发到i,0 只有一条路径
dp[0][j] 同理
```

4）遍历顺序
从左到右一层层遍历就可以了


## 1.4 不同路径2

https://leetcode-cn.com/problems/unique-paths-ii/

题目分析：考虑到障碍物，障碍物是不可达的，如果障碍物的坐标为a,b 那么`dp[a][b]=0`

注意：只要是遇到为0的dp 直接跳出？

1） 2） 的步骤是一样的
3）初始化的时候，需要考虑当为障碍物的时候 ，初始为0
4）遍历顺序同上

特殊判断：当初起点和终点存在障碍物的时候，直接返回0
```java
//如果在起点或终点出现了障碍，直接返回0  
if (obstacleGrid[m - 1][n - 1] == 1 || obstacleGrid[0][0] == 1) {  
    return 0;  
}
```



## 1.5 整数拆分

https://leetcode.cn/problems/integer-break/

1）确定dp数组和下标的含义
```
dp[i] 表示在整数i 在拆分之后的最大值
```

2）递推公式
```
两个渠道：
两层遍历 i j i是当前的整数，j是拆分的数
1）（i-j）*j 两者直接相乘最大
2）dp[i-j]*j 或者i-j 继续拆分
```

3）初始化
```
dp[1]=1
dp[2]=1
```

4）遍历
```
for int i=3;i<=n;i++{

for int j=1;j<i-1;j++{

  }
}
```

## 1.6 不同的二叉搜索树



# 2、背包问题

掌握0、1背包和完全背包

![[Pasted image 20230307222305.png]]



## 2.1 01 背包问题

![[Pasted image 20230307222500.png]]

1）确定dp数组和下标的含义
```
dp[i][j] 从下标为[0-i]的物品里面任意取，放入容量为j的背包中，价值总和最大是多少
```

2）确定递推公式

```
dp[i][j] 可以从两个地方进推导

1）dp[i-1][j]推出， 当背包容量为j的时候，不选择i的时候，获取到的价值最大总和
2）dp[i-1][j-weight[i]] 推出，当背包容量为j-weight[i]的时候，不选择i物品的最大值，那么dp[i-1][j-weight[i]]+value[i] 就是背包放入物品i之后的，获取到的价值最大总和

所以递推公式为：
dp[i][j]=Math.max(dp[i-1][j],dp[i-1][j-weight[i]]+value[i])
```

3）dp数组的初始化

```
dp[i][j] 如果j=0的时候 说明没有容量，直接=0

如果i=0的时候，当存放编号为0的物品的时候，各个容量背包能存放的最大价值

当j<weight[0]的时候，dp[0][j]=0，因为背包容量比编号为0的物品重量还要小
当j>=weight[0]的时候，dp[0][j]=value[0],因为背包容量能够存放编号为0的物品，直接放入即可
```

![[Pasted image 20230307224424.png]]

![[Pasted image 20230312212512.png]]


4）遍历顺序
 从左上方开始，先遍历物品后遍历背包


变成一维递归数组：

1）dp[j] 表示当背包容量为j的时候，所背的物品最大值为dp[j]
2)递推公式：要么选择自己当前，要么选择从上一个容量从转化出来
  dp[j]可以通过dp[j - weight[j]]推导出来，dp[j - weight[i]]表示容量为j - weight[i]的背包所背 的最大价值。
 dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
3）初始化
```
dp[j]表示:容量为j的背包，所背的物品价值可以最大为dp[j]，那么dp[0]就应该是0，因为
背包容量为0所背的物品的最大价值就是0。

其他的位置，按照递推公式 都是找到的最大值，dp数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖了。如果假定最大值为0，那么初始值都是0了。
```
4）一维dp数组的遍历顺序
```
二维dp遍历的时候，背包容量是从小到大，而一维dp遍历的时候，背包是从大到小。
使用逆序的方式进行遍历
```

5）最终代码
```
int[] weightSize=new int[]{}
int[] value=new int[]{}
int bagWeight=4;
int[] dp=new int[bagWeight+1];
for(int i=0;i<weightSize.lenght;i++){// 遍历物品
	for(int j=bagWeight;j>=weightSize[i];j--){// 遍历背包的容量
		dp[j]=Math.Max(dp[j],dp[j-weight[i]]+value[i]);
	}
}

```

## 2.2 分割等和子集

https://leetcode-cn.com/problems/partition-equal-subset-sum/


- 背包的体积为nums/2
- 背包要放入的商品(集合里的元素)重量为 元素的数值，价值也为元素的数值
- 背包如何正好装满，说明找到了总和为 sum / 2 的子集。
- 背包中每一个元素是不可重复放入。

1、确定dp数组的下标和含义
`01背包中，dp[j] 表示: 容量为j的背包，所背的物品价值最大为dp[j]。
`在本题目中，dp[i]表示，背包总容量是i，所背的物品价值最大为dp[i]，然后判断最后这个价值是否等于target，如果等于说明背包正好被装满`

2、递归公式
```
01背包的递推公式为:dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

在本题中，物品的重量为nums[i] 价值也为nums[i]
所以递推公式为：
dp[i]=max(dp[i],dp[j-nums[i]]+nums[i])
```

3、dp数组如何初始化
```
本题题目中 只包含正整数的非空数组，所以非0下标的元素初始化为0就可以了。
```
4、遍历顺序
```
// 开始 01背包  
for(int i = 0; i < nums.size(); i++) {
for(int j = target; j >= nums[i]; j--) { // 每一个元素一定是不可重复放入，所以从大到小遍历
    dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);
    }
}
```

5、代码
```
public boolean canPartition(int[] nums) {  
    int sum = 0;  
    for (int num : nums) { sum += num; }  
    if (sum % 2 != 0) {  
        return false;  
    }  
    int target = sum / 2;  
  
    int[] dp = new int[target + 1];  
    for (int i = 0; i < nums.length; i++) {  
        for (int j = target; j >= nums[i]; j--) {  
            dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);  
        }  
    }  
  
    if (dp[target] == target) return true;  
  
    return false;
}
```
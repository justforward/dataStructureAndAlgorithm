# 比较排序

## 快速排序

### 思路

#### 原地排序

三个步骤：
1.选择基准值：在待排序列中，按照某种方式挑出一个元素，作为基准值。  
2.分割操作：以该基准值在序列中的实际位置，把序列分成两个子序列，一边是比它大的值，另外一边是比它小的值。  
3.递归：对两个子序列进行快排，直到序列为空或者只有一个元素。

```
public static void sort(int[] nums, int left, int right) {  
    if (left >= right) {  
        return;  
    }  
    // 基数从数组的最左边的一个元素  
    int base = nums[left];  
    int i = left;  // 需要保存最后的位置，递归的时候需要
    int j = right;  
    while (i < j) {  
        while (i < j && nums[j] >= base) {  
            j--;  
        }  
        while (i < j && nums[i] <= base) {  
            i++;  
        }  
  
        int tmp = nums[i];  
        nums[i] = nums[j];  
        nums[j] = tmp;  
    }  
  
    // 当前i所停下的位置一定是小于base的，所以需要将i的位置存放到left位置上  
    nums[left] = nums[i];  
    // 然后进行base数据放到应该存放的位置  
    nums[i] = base;  
    // 递归排序左边  
    sort(nums, left, i - 1);  
    // 递归排序右边  
    sort(nums, i + 1, right);  
}
```

#### 快排为什么要从右边开始？

从右边先开始的前提是我们选择序列中最左边的元素最为基准值。  
先从右边开始可以保证i,j相等的时候，***arr[i] = arr[j] 小于基准值p***。这样交换之后才能保证基准值左右两边分别小于和大于它的值。  
我们图片演示一下：

![](Pasted%20image%2020221127164802.png)

可以发现如果我们选择的是序列中最左边的元素为基准值，先从左边开始移动 不能保证`arr[i]==arr[j]` 的时候 当前指向的值小于基数值。




## 归并排序


```

```


# 非比较排序

## 桶排序

工作原理是将数组分到有限数量的桶子里，每个桶子在个别排序（有可能再使用别的排序算法或者是以递归方式继续使用桶排序进行排序）

桶排序是鸽巢排序中的一种归纳结果。

当被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间O(n)。但桶排序并不是比较排序，他不受O(nlog n)下限的影响。


### 基本思想

```
 假设有一组长度为N的待排关键字序列K[1....n]。首先将这个序列划分成M个的子区间(桶) 。然后基于某种映射函数 ，将待排序列的关键字k映射到第i个桶中(即桶数组B的下标 i) ，那么该关键字k就作为B[i]中的元素(每个桶B[i]都是一组大小为N/M的序列)。接着对每个桶B[i]中的所有元素进行比较排序(可以使用快排)。然后依次枚举输出B[0]....B[M]中的全部内容即是一个有序序列。
```

![[Pasted image 20221229102454.png]]


#### 关键一：映射函数

```
  bindex=f(key)   其中，bindex 为桶数组B的下标(即第bindex个桶), k为待排序列的关键字。桶排序之所以能够高效，其关键在于这个映射函数，它必须做到：如果关键字k1<k2，那么f(k1)<=f(k2)。也就是说B(i)中的最小数据都要大于B(i-1)中最大数据。很显然，映射函数的确定与数据本身的特点有很大的关系，我们下面举个例子:
    
```

**例子**

```
假如待排序列K= {49、 38 、 35、 97 、 76、 73 、 27、 49 }。这些数据全部在1—100之间。因此我们定制10个桶，然后确定映射函数f(k)=k/10。则第一个关键字49将定位到第4个桶中(49/10=4)。依次将所有关键字全部堆入桶中，并在每个非空的桶中进行快速排序后得到如下图所示：
```

![[Pasted image 20221229102731.png]]

对上图只要是顺序输出每个B[i] 中的数据就可以得到有序序列了。

#### 桶排序代价分析

桶排序利用函数的映射关系，减少了几乎所有的比较工作。实际上，桶排序的f(k)值的计算，其作用就相当于快排中划分，已经把大量数据分割成了基本有序的数据块(桶)。然后只需要对桶中的少量数据做先进的比较排序即可。

对N个关键字进行桶排序的时间复杂度分为两个部分：

(1) 循环计算每个关键字的桶映射函数，这个时间复杂度是O(N)。

(2) 利用先进的比较排序算法对每个桶内的所有数据进行排序，其时间复杂度为  ∑ O(Ni*logNi) 。其中Ni 为第i个桶的数据量。




   

# 快速排序

## 思路

### 原地排序

三个步骤：
1.选择基准值：在待排序列中，按照某种方式挑出一个元素，作为基准值。  
2.分割操作：以该基准值在序列中的实际位置，把序列分成两个子序列，一边是比它大的值，另外一边是比它小的值。  
3.递归：对两个子序列进行快排，直到序列为空或者只有一个元素。

```
public static void sort(int[] nums, int left, int right) {  
    if (left >= right) {  
        return;  
    }  
    // 基数从数组的最左边的一个元素  
    int base = nums[left];  
    int i = left;  
    int j = right;  
    while (i < j) {  
        while (i < j && nums[j] >= base) {  
            j--;  
        }  
        while (i < j && nums[i] <= base) {  
            i++;  
        }  
  
        int tmp = nums[i];  
        nums[i] = nums[j];  
        nums[j] = tmp;  
    }  
  
    // 当前i所停下的位置一定是小于base的，所以需要将i的位置存放到left位置上  
    nums[left] = nums[i];  
    // 然后进行base数据放到应该存放的位置  
    nums[i] = base;  
    // 递归排序左边  
    sort(nums, left, i - 1);  
    // 递归排序右边  
    sort(nums, i + 1, right);  
}
```

### 快排为什么要从右边开始？

从右边先开始的前提是我们选择序列中最左边的元素最为基准值。  
先从右边开始可以保证i,j相等的时候，***arr[i] = arr[j] 小于基准值p***。这样交换之后才能保证基准值左右两边分别小于和大于它的值。  
我们图片演示一下：

![](Pasted%20image%2020221127164802.png)

可以发现如果我们选择的是序列中最左边的元素为基准值，先从左边开始移动 不能保证`arr[i]==arr[j]` 的时候 当前指向的值小于基数值。


# 归并排序

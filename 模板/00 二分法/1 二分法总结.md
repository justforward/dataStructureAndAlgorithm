总结阅读：
https://leetcode.cn/circle/discuss/ooxfo8/#%E6%83%85%E5%BD%A21-%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E

## 本质

二分的本质是「二段性」而非「单调性」



## 基础模板

### 1）寻找一个数

```
public int searchInsert(int[] nums, int target) {  
    int left = 0, right = nums.length - 1;  
  
    while (left <= right) { // left==right+1 的是区间停止  
        int mid = left + (right - left) / 2;  
        if (nums[mid] == target) {  
            return mid;  
        }  
        if (nums[mid] > target) { // 因为mid已经对比过  
            right = mid - 1;  
        }  
        if (nums[mid] < target) {  
            left = mid + 1;  
        }  
    }  
    return -1;  
}
```
 
**1、为什么 while 循环的条件中是 <=，而不是 <**？

答：因为初始化 `right` 的赋值是 `nums.length - 1`，即最后一个元素的索引，而不是 `nums.length`。

这二者可能出现在不同功能的二分查找中，区别是：前者相当于两端都闭区间 `[left, right]`，后者相当于左闭右开区间 `[left, right)`，因为索引大小为 `nums.length` 是越界的。

我们这个算法中使用的是前者 `[left, right]` 两端都闭的区间。**这个区间其实就是每次进行搜索的区间**。

**2、终止条件是什么？**

while(left<=right) 的终止条件是**left=right+1** ，写成区间的形式就是 `[right + 1, right]`，或者带个具体的数字进去 `[3, 2]`，可见**这时候区间为空**，因为没有数字既大于等于 3 又小于等于 2 的吧。所以这时候 while 循环终止是正确的，直接返回 -1 即可。

`while(left < right)` 的终止条件是 `left == right`，写成区间的形式就是 `[right, right]`，或者带个具体的数字进去 `[2, 2]`，**这时候区间非空**，还有一个数 2，但此时 while 循环终止了。也就是说这区间 `[2, 2]` 被漏掉了，索引 2 没有被搜索，如果这时候直接返回 -1 就是错误的。

当然，如果你非要用 `while(left < right)` 也可以，我们已经知道了出错的原因，就打个补丁好了：
```
... while(left < right) { 
 ... } 
return nums[left] == target ? left : -1;
```
 
 **3、为什么 `left = mid + 1`，`right = mid - 1`？我看有的代码是 `right = mid` 或者 `left = mid`，没有这些加加减减，到底怎么回事，怎么判断**？

答：这也是二分查找的一个难点，不过只要你能理解前面的内容，就能够很容易判断。

刚才明确了「搜索区间」这个概念，而且本算法的搜索区间是两端都闭的，即 `[left, right]`。那么当我们发现索引 `mid` 不是要找的 `target` 时，下一步应该去搜索哪里呢？

当然是去搜索区间 `[left, mid-1]` 或者区间 `[mid+1, right]` 对不对？**因为 `mid` 已经搜索过，应该从搜索区间中去除**。

**3、此算法有什么缺陷**？

答：至此，你应该已经掌握了该算法的所有细节，以及这样处理的原因。但是，这个算法存在局限性。

比如说给你有序数组 `nums = [1,2,2,2,3]`，`target` 为 2，此算法返回的索引是 2，没错。但是如果我想得到 `target` 的左侧边界，即索引 1，或者我想得到 `target` 的右侧边界，即索引 3，这样的话此算法是无法处理的。

这样的需求很常见，**你也许会说，找到一个 `target`，然后向左或向右线性搜索不行吗？可以，但是不好，因为这样难以保证二分查找对数级的复杂度了**。

我们后续的算法就来讨论这两种二分查找的算法

### 2) 寻找数的边界

#### 寻找数的左边界

如果一个数在某个搜索区间中一定存在左边界

```
int left_bound(int[] nums, int target) { 
// 搜索区间为 [left, right] 
int left = 0, right = nums.length - 1; 
while (left <= right) { 
	int mid = left + (right - left) / 2; 
	// if else ... 
	if (nums[mid] < target) { 
	   // 搜索区间变为 [mid+1, right] 
	    left = mid + 1; 
	} else if (nums[mid] > target) { 
	 // 搜索区间变为 [left, mid-1] 
	    right = mid - 1; 
	} else if (nums[mid] == target) { 
	// 收缩右侧边界 
	   right = mid - 1;
	 }

 // 此时 target 比所有数都大，返回 -1 
     if (left == nums.length)  return -1;
      // 判断一下 nums[left] 是不是 target
     return nums[left] == target ? left : -1;
}
```

#### 寻找数的右边界

如果一个数在某个搜索区间中一定存在右边界
```
public int right_bound(int[] nums, int target) {  
    int left = 0, right = nums.length - 1;  
    while (left <= right) {  
        int mid = left + (right - left) / 2;  
        if (nums[mid] < target) {  
            left = mid + 1;  
        } else if (nums[mid] > target) {  
            right = mid - 1;  
        } else if (nums[mid] == target) {  
            // 这里改成收缩左侧边界即可  
            left = mid + 1;  
        }  
    }  
    // 最后改成返回 left - 1 由于终止条件是[right,right+1] right=left-1 此时  
    if (right < 0) return -1;  
    return nums[right] == target ? right : -1;  
}
```


#### 左边界大于等于某个数

针对区间内一定会存在一个数是大于给定x数字的，最后需要返回left所指定的位置

**一定是大于 不能等于 所以等于的时候需要跳过mid**
```
public int binarySearch(int x) {  
    int left = 0, right = pre.length - 1;  
    while (left <= right) {  
        int mid = left + (right - left) / 2;  
        if (pre[mid] < x) left = mid + 1; // 直接跳过mid  
        else right = mid - 1; // 针对满足条件的，别返回 继续缩小搜索空间去找边界
    }  
    // 找到首个大于x的位置  
    return left;  
}
```

#### 小于等于某个数的右边界

```
public int mySqrt(int x) {  
    if (x == 1) return 1;  
    // 二分查找，根据x 得到  
    // 为什么right 取中值，因为开方之后不可能大于中间的值    int left = 1, right = x / 2;  
    while (left <= right) {  
        int mid = left + (right - left) / 2;  
        if (mid > x / mid) {  
            right = mid - 1;  
        } else if (mid < x / mid) {  
            left = mid + 1;  
        } else {  
            return mid;  
        }  
    }  
    // 锁定右边的区间  
    return right;  
}

```


## 例题

### [剑指 Offer II 068. 查找插入位置](https://leetcode.cn/problems/N6YdxV/)

#### 思路：

***为什么找到的最终位置返回left？**

* while的每一次执行都将使得right或left的位置相比当前center位置左移/右移一位，不难分析出无法进入while时的right和left的关系一定是right = left - 1。反推上一次能够进入while的情形：  
*  
* 如果上一次进入while后是target < nums[mid]，right被更新，right = center - 1，已知当前right = left - 1，说明当前left = center，由于target < nums[mid]，插入位置是center（即left），也就是center（left）这个坐标的元素及其右边元素(直到i的左一位)，都要向右移动一位。  
*  
* 如果上一次进入while后是target > nums[mid]，left被更新，left = center + 1，已知当前right = left - 1，说明当前right = center，由于target ≥ nums[mid]，插入位置是center+1（即left），也就是center+1（left）这个坐标的元素及其右边元素(直到i的左一位)，都要向右移动一位。  
*  
* 以上结果均使得插入位置为当前的left (或当前的right + 1)。

```
public int searchInsert(int[] nums, int target) {  
    int left = 0, right = nums.length - 1;  
  
    while (left <= right) { // left==right+1 的是区间停止  
        int mid = left + (right - left) / 2;  
        if (nums[mid] == target) {  
            return mid;  
        }  
        if (nums[mid] > target) { // 因为mid已经对比过  
            right = mid - 1;  
        }  
        if (nums[mid] < target) {  
            left = mid + 1;  
        }  
    }  
    return left;  
}
```


### leetcode_162

#### 题目

在一个数组中寻找峰值，峰值元素是指其值严格大于左右相邻值的元素。

#### 思路

在确保有解的情况下，我们可以根据当前的分割点mid 与左右元素的大小关系来设定l或者r的移动。

利用题目发现如下性质：**由于 `arr` 数值各不相同，因此峰顶元素左侧必然满足严格单调递增，峰顶元素右侧必然不满足。**

因此 以峰顶元素为分割点的 arr 数组，根据与 前一元素/后一元素 的大小关系，具有二段性：

峰顶元素左侧满足 arr[i-1] < arr[i] 性质，右侧不满足
峰顶元素右侧满足 arr[i] > arr[i+1]性质，左侧不满足



#### 代码
```
int l = 0, r = nums.length - 1;  
while (l < r) {  
    int mid = l + (r - l) / 2;  
    // 中间值去判断大小 锁定二分区间
    if (nums[mid] > nums[mid + 1]) r = mid;  
    else l = mid + 1;  
}  
// 返回r 和返回l 性质是一样的
return r;
```

使用mid判断

```
public int peakIndexInMountainArray(int[] arr) {  
    int left = 0, right = arr.length - 1;  
    int mid = 0;  
    while (left <= right) { //break 的前提 由于这个值一定存在峰值，这个可以忽略  
        mid = left + (right - left) / 2;  
        if (arr[mid - 1] < arr[mid] && arr[mid + 1] < arr[mid]) {  
            // 说明这个点是峰值  
            break;  
        }  

		// 右边才是递增 右边比mid高
        if (arr[mid + 1] > arr[mid]) left = mid;  
		// 左边比mid高，左边才有可能存在山峰
		// 左边 arr[mid-1]>arr[mid] 已经不满足递增条件，只能从左边找
        if (arr[mid + 1] < arr[mid]) right = mid;  
    }  
    return mid;  
}
```





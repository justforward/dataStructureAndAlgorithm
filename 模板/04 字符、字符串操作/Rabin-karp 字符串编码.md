一个字符串s的编码值计算公式如下：
![[Pasted image 20221118213620.png]]

其中base为选定的进制单位，例如，本题中s仅包含26个小写字母，因此base可以取到一个大于26的数（如base=31）.

如果两个字符串shet相等，当且仅当他们的长度相等并且编码值xiangdeng：
`len(s)==len(t) && encode(s)==encode(t)`

***leetcode_1044***

本题要求：返回任意一个可能具有最长长度的重复子串。

分析发现：若存在size长度的子串满足题意 则size-1长度的子串也一定满足在题意的重复子串，因此满足二分搜索的特性。

接下来问题就转化为了如何维护一个长度一定的滑动窗口，对于其内的字符串计算其哈希编码值，若出现同样的编码值，则说明找到了重复字串。

题目要求得 「能取到最大长度的任一方案」，首先以「最大长度」为分割点的数轴具有「二段性」：
- 小于等于最大长度方案均存在（考虑在最长大度方案上做删减）
- 大于最大长度的方案不存在

二分范围为 [0, n][0,n]，关键在于如何 `check` 函数，即实现「检查某个长度 len 作为最大长度，是否存在合法方案」。

基于二分搜索：

- 若长度为 size 的子字符串存在重复，则考虑增加子字符串的长度。
- 若长度为 size 的子字符串不存在重复，则考虑缩小子字符串的长度。

长度为 mm 的子字符串的编码表示：
记 `hash[i+1]`表示以 s[i]结尾的长为 m 的子字符串` s[i-m+1,...,i]s[i−m+1,...,i]` 的哈希编码值。

得到递推关系：加入s[i],去除s[i-m]

![[Pasted image 20221118214727.png]]

***为什么需要两次hash？***

还有一点需要考虑的是，本题中 a^L会非常大。一般的做法是需要对编码进行取模来防止溢出，模一般选取编码的信息量的平方的数量级。而取模则会带来哈希碰撞。本题中为了避免碰撞，我们使用双哈希，即用两套进制和模的组合，来对字符串进行编码。只有两种编码都相同时，我们才认为字符串相同。





